"""Apple Wallet .pkpass MCP server.

Tools: wallet.generate_pkpass

This is a thin wrapper â€” the actual generation logic is in the
backend service (wallet_pass.py). The MCP tool interface allows
it to be called uniformly via the tool_router.
"""

from __future__ import annotations

from typing import Any

from mcp_servers.common.server import is_mock_mode, mock_response


async def handle_tool(method: str, payload: dict[str, Any]) -> dict[str, Any]:
    """Handle wallet.generate_pkpass."""
    if method == "generate_pkpass":
        return await _generate_pkpass(payload)
    raise ValueError(f"Unknown method: wallet.{method}")


async def _generate_pkpass(payload: dict[str, Any]) -> dict[str, Any]:
    trip_id = payload.get("trip_id", "unknown")
    user_id = payload.get("user_id", "anonymous")

    if is_mock_mode():
        return mock_response({
            "status": "generated",
            "trip_id": trip_id,
            "pass_type": "boardingPass",
            "message": "Mock .pkpass generated. Use /wallet/pkpass endpoint to download.",
        })

    # In real mode, the actual .pkpass bytes are generated by wallet_pass.py
    # This MCP tool just confirms the generation request
    return {
        "status": "generated",
        "trip_id": trip_id,
        "message": "Pass generation requested. Download via /wallet/pkpass endpoint.",
    }
